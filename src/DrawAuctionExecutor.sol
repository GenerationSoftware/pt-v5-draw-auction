// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

import { PrizePool } from "v5-prize-pool/PrizePool.sol";

import { ExecutorAware } from "src/abstract/ExecutorAware.sol";
import { AuctionLib } from "src/auctions/Auction.sol";
import { RewardLib } from "src/libraries/RewardLib.sol";
import { console2 } from "forge-std/Test.sol";

contract DrawAuctionExecutor is ExecutorAware {
  /* ============ Events ============ */

  /**
   * @notice Emitted when an auction has completed and rewards have been distributed.
   * @param phaseIds Ids of the phases
   * @param rewardRecipients Addresses of the rewards recipients per phase id
   * @param rewardAmounts Amounts of rewards distributed per phase id
   */
  event AuctionRewardsDistributed(
    uint8[] phaseIds,
    address[] rewardRecipients,
    uint256[] rewardAmounts
  );

  /* ============ Custom Errors ============ */

  /// @notice Thrown when the originChainId passed to the constructor is zero.
  error OriginChainIdZero();

  /// @notice Thrown when the DrawAuctionDispatcher address passed to the constructor is zero address.
  error DrawAuctionDispatcherZeroAddress();

  /// @notice Thrown if the DrawAuctionDispatcher has already been set.
  error DrawAuctionDispatcherAlreadySet();

  /// @notice Thrown when the PrizePool address passed to the constructor is zero address.
  error PrizePoolZeroAddress();

  /// @notice Thrown when the message was dispatched from an unsupported chain ID.
  error L1ChainIdUnsupported(uint256 fromChainId);

  /// @notice Thrown when the message was not executed by the executor.
  error L2SenderNotExecutor(address sender);

  /// @notice Thrown when the message was not dispatched by the DrawAuctionDispatcher on the origin chain.
  error L1SenderNotDispatcher(address sender);

  /* ============ Variables ============ */

  /// @notice ID of the origin chain that dispatches the auction phases and random number.
  uint256 internal immutable _originChainId;

  /// @notice Address of the DrawAuctionDispatcher on the origin chain that dispatches the auction phases and random number.
  address internal _drawAuctionDispatcher;

  /// @notice Instance of the PrizePool on the destination chain to compute Draw for.
  PrizePool internal immutable _prizePool;

  /* ============ Constructor ============ */

  /**
   * @notice DrawAuctionExecutor constructor.
   * @param originChainId_ ID of the origin chain
   * @param _executor Address of the ERC-5164 contract that executes the bridged calls
   * @param prizePool_ Address of the prize pool
   */
  constructor(
    uint256 originChainId_,
    address _executor,
    PrizePool prizePool_
  ) ExecutorAware(_executor) {
    if (originChainId_ == 0) revert OriginChainIdZero();
    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();

    _originChainId = originChainId_;
    _prizePool = prizePool_;
  }

  /* ============ External Functions ============ */

  /**
   * @notice Complete the auction and current draw.
   * @param _auctionPhases Array of auction phases
   * @param _auctionDuration Duration of the auction in seconds
   * @param _randomNumber Random number generated by the RNG service on the origin chain
   */
  function completeAuction(
    AuctionLib.Phase[] memory _auctionPhases,
    uint32 _auctionDuration,
    uint256 _randomNumber
  ) public {
    _checkSender();

    uint256[] memory _rewards = RewardLib.rewards(_auctionPhases, _prizePool, _auctionDuration);

    _prizePool.completeAndStartNextDraw(_randomNumber);

    AuctionLib.Phase memory _startRNGPhase = _auctionPhases[0];
    AuctionLib.Phase memory _completeRNGPhase = _auctionPhases[1];

    if (_startRNGPhase.recipient == _completeRNGPhase.recipient) {
      _prizePool.withdrawReserve(_startRNGPhase.recipient, uint104(_rewards[0] + _rewards[1]));
    } else {
      _prizePool.withdrawReserve(_startRNGPhase.recipient, uint104(_rewards[0]));
      _prizePool.withdrawReserve(_completeRNGPhase.recipient, uint104(_rewards[1]));
    }

    uint8[] memory _phaseIds = new uint8[](2);
    _phaseIds[0] = _startRNGPhase.id;
    _phaseIds[1] = _completeRNGPhase.id;

    address[] memory _rewardRecipients = new address[](2);
    _rewardRecipients[0] = _startRNGPhase.recipient;
    _rewardRecipients[1] = _completeRNGPhase.recipient;

    emit AuctionRewardsDistributed(_phaseIds, _rewardRecipients, _rewards);
  }

  /* ============ Getter Functions ============ */

  /**
   * @notice Get the ID of the origin chain.
   * @return ID of the origin chain
   */
  function originChainId() public view returns (uint256) {
    return _originChainId;
  }

  /**
   * @notice Get the address of the DrawAuctionDispatcher on the origin chain.
   * @return Address of the DrawAuctionDispatcher on the origin chain
   */
  function drawAuctionDispatcher() public view returns (address) {
    return _drawAuctionDispatcher;
  }

  /**
   * @notice Get the instance of the PrizePool on the receiving chain.
   * @return Instance of the PrizePool on the receiving chain
   */
  function prizePool() public view returns (PrizePool) {
    return _prizePool;
  }

  /* ============ Setters ============ */

  /**
   * @notice Set the DrawAuctionDispatcher address.
   * @dev Can only be called once.
   *      If the transaction get front-run at deployment, we can always re-deploy the contract.
   */
  function setDrawAuctionDispatcher(address drawAuctionDispatcher_) public {
    if (_drawAuctionDispatcher != address(0)) revert DrawAuctionDispatcherAlreadySet();
    if (drawAuctionDispatcher_ == address(0)) revert DrawAuctionDispatcherZeroAddress();

    _drawAuctionDispatcher = drawAuctionDispatcher_;
  }

  /* ============ Internal Functions ============ */

  /**
   * @notice Checks that:
   *          - the call has been dispatched from the supported chain
   *          - the sender on the receiving chain is the executor
   *          - the sender on the origin chain is the DrawDispatcher
   */
  function _checkSender() internal view {
    if (_fromChainId() != _originChainId) revert L1ChainIdUnsupported(_fromChainId());
    if (!isTrustedExecutor(msg.sender)) revert L2SenderNotExecutor(msg.sender);
    if (_msgSender() != address(_drawAuctionDispatcher)) revert L1SenderNotDispatcher(_msgSender());
  }
}
