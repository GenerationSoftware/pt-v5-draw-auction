// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.17;

// import "forge-std/console2.sol";

import { PrizePool } from "v5-prize-pool/PrizePool.sol";
import { PhaseManager, Phase } from "draw-auction-local/abstract/PhaseManager.sol";
import { OnlyPhaseManager, IDrawAuction } from "draw-auction-local/interfaces/IDrawAuction.sol";
import { RNGInterface } from "rng/RNGInterface.sol";
import { RewardLib } from "draw-auction-local/libraries/RewardLib.sol";

/**
 * @title PoolTogether V5 DrawAuction
 * @author PoolTogether Inc. Team
 * @notice The DrawAuction uses an auction mechanism to incentivize the completion of the Draw.
 *         This mechanism relies on a linear interpolation to incentivizes anyone to start and complete the Draw.
 *         The first user to complete the Draw gets rewarded with the partial or full PrizePool reserve amount.
 */
contract DrawAuction is IDrawAuction {
  /**
   * @notice Emitted when an auction has completed and rewards have been distributed.
   * @param phases The phases that were submitted
   * @param randomNumber The random number submitted
   * @param rewardAmounts Amounts of rewards distributed per phase id
   */
  event AuctionRewardsDistributed(Phase[] phases, uint256 randomNumber, uint256[] rewardAmounts);

  /* ============ Variables ============ */

  /// @notice Instance of the PrizePool to compute Draw for.
  PrizePool internal immutable _prizePool;

  address internal immutable _phaseManager;

  uint32 internal immutable _auctionDuration;

  /* ============ Custom Errors ============ */

  /// @notice Thrown when the PrizePool address passed to the constructor is zero address.
  error PrizePoolZeroAddress();

  /* ============ Constructor ============ */

  /**
   * @notice Contract constructor.
   * @param prizePool_ Address of the prize pool
   * @param phaseManager_ Phase manager that is pushing the phases
   * @param auctionDuration_ The duration that the auction should run
   */
  constructor(PrizePool prizePool_, address phaseManager_, uint32 auctionDuration_) {
    if (address(prizePool_) == address(0)) revert PrizePoolZeroAddress();
    _prizePool = prizePool_;
    _phaseManager = phaseManager_;
    _auctionDuration = auctionDuration_;
  }

  /* ============ External Functions ============ */

  /* ============ Getter Functions ============ */

  /**
   * @notice Prize Pool instance for which the Draw is triggered.
   * @return Prize Pool instance
   */
  function prizePool() external view returns (PrizePool) {
    return _prizePool;
  }

  /**
   * @notice Phase manager that is pushing the phases.
   * @return the address of the phase manager
   */
  function phaseManager() external view returns (address) {
    return _phaseManager;
  }

  /**
   * @notice Reward for completing the Auction phase.
   * @param _phase Phase to get reward for
   * @return Reward amount
   */
  function reward(Phase calldata _phase) external view returns (uint256) {
    return RewardLib.reward(_phase, _prizePool, _auctionDuration);
  }

  /* ============ Internal Functions ============ */

  /* ============ Hooks ============ */

  /**
   * @notice Hook called after the auction has ended.
   * @param _auctionPhases Array of auction phases
   * @param _randomNumber Random number generated by the RNG service
   */
  function completeAuction(
    Phase[] memory _auctionPhases,
    uint256 _randomNumber
  ) external override onlyPhaseManager {
    uint256[] memory _rewards = RewardLib.rewards(_auctionPhases, _prizePool, _auctionDuration);

    _prizePool.closeDraw(_randomNumber);

    for (uint i = 0; i < _rewards.length; i++) {
      // console2.log("rewardddd", _rewards[i]);
      _prizePool.withdrawReserve(_auctionPhases[i].recipient, uint104(_rewards[i]));
    }

    emit AuctionRewardsDistributed(_auctionPhases, _randomNumber, _rewards);
  }

  modifier onlyPhaseManager() {
    if (msg.sender != _phaseManager) {
      revert OnlyPhaseManager();
    }
    _;
  }
}
